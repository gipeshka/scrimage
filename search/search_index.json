{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Scrimage is an immutable, functional, and performant JVM library for manipulation of images. The aim of this library is to provide a simple and concise way to do common image operations, such as resizing to fit a required width and height, converting between formats, applying filters and so on. It is not intended to provide functionality that might be required by a more \"serious\" image processing application - such as face recognition or movement tracking. A typical use case for this library would be creating thumbnails of images uploaded by users in a web app, or bounding a set of product images so that they all have the same dimensions, or optimizing PNG uploads by users to apply maximum compression, or applying a grayscale filter in a print application. Scrimage mostly builds on the functionality provided by java.awt.* along with selected other third party libraries, such as drewnoakes/metadata-extractor and haraldk/TwelveMonkeys . Creation methods Creation methods create a new image by specifying the dimensions. They can start with a specified colour using fill or undefined using blank . An image can be created by copying an existing image. Input / Output The heart of any image library is reading and writing in the various formats. Scrimage supports all the formats provided by javax.imageio along with extra formats in the modules scrimage-formats-extra and scrimage-webp . Image Operations These operations operate on an image, returning a copy of that image. For instance, fit will resize an image to fit into a specified set of bounds, and scale will change the size of an image. For the full list of operations, see the menu on the left. Filters Scrimage comes with a wide array of filters in the module scrimage-filters . Composites Metadata Scrimage builds on the metadata-extractor project to provide the ability to read metadata from an image. Read more details here . Quick Examples Reading an image, scaling it to 50% using the Bicubic method, and writing out as PNG val in = ... // input stream val out = ... // output stream ImmutableImage . loader (). fromStream ( in ). scale ( 0.5 , Bicubic ). output ( out ) // an implicit PNG writer is in scope by default Reading an image from a java File, applying a blur filter, then flipping it on the horizontal axis, then writing out as a Jpeg val inFile = ... // input File val outFile = ... // output File ImmutableImage . loader (). fromFile ( inFile ). filter ( BlurFilter ). flipX . output ( outFile )( JpegWriter ()) // specified Jpeg Padding an image with a 20 pixel border around the edges in red val in = ... // input stream val out = ... // output stream ImmutableImage . loader (). fromStream ( in ). pad ( 20 , Color . Red ) Enlarging the canvas of an image without scaling the image. Note: the resize methods change the canvas size, and the scale methods are used to scale/resize the actual image. This terminology is consistent with Photoshop. val in = ... // input stream val out = ... // output stream ImmutableImage . loader (). fromStream ( in ). resize ( 600 , 400 ) Scaling an image to a specific size using a fast non-smoothed scale val in = ... // input stream val out = ... // output stream ImmutableImage . loader (). fromStream ( in ). scaleTo ( 300 , 200 , FastScale ) Writing out a heavily compressed Jpeg thumbnail implicit val writer = JpegWriter (). withCompression ( 50 ) val in = ... // input stream val out = ... // output stream ImmutableImage . loader (). fromStream ( in ). fit ( 180 , 120 ). output ( new File ( \"image.jpeg\" )) Printing the sizes and ratio of the image val in = ... // input stream val out = ... // output stream val image = ImmutableImage . loader (). fromStream ( in ) println ( \"Width: ${ image . width } Height: ${ image . height } Ratio: ${ image . ratio } \" ) Converting a byte array in JPEG to a byte array in PNG val in : Array [ Byte ] = ... // array of bytes in JPEG say val out = Image ( in ). write // default is PNG val out2 = ImmutableImage . loader (). fromBytes ( in ). bytes ) // an implicit PNG writer is in scope by default with max compression Coverting an input stream to a PNG with no compression implicit val writer = PngWriter . NoCompression val in : InputStream = ... // some input stream val out = ImmutableImage . loader (). fromStream ( in ). stream","title":"Welcome"},{"location":"#_1","text":"Scrimage is an immutable, functional, and performant JVM library for manipulation of images. The aim of this library is to provide a simple and concise way to do common image operations, such as resizing to fit a required width and height, converting between formats, applying filters and so on. It is not intended to provide functionality that might be required by a more \"serious\" image processing application - such as face recognition or movement tracking. A typical use case for this library would be creating thumbnails of images uploaded by users in a web app, or bounding a set of product images so that they all have the same dimensions, or optimizing PNG uploads by users to apply maximum compression, or applying a grayscale filter in a print application. Scrimage mostly builds on the functionality provided by java.awt.* along with selected other third party libraries, such as drewnoakes/metadata-extractor and haraldk/TwelveMonkeys .","title":""},{"location":"#creation-methods","text":"Creation methods create a new image by specifying the dimensions. They can start with a specified colour using fill or undefined using blank . An image can be created by copying an existing image.","title":"Creation methods"},{"location":"#input-output","text":"The heart of any image library is reading and writing in the various formats. Scrimage supports all the formats provided by javax.imageio along with extra formats in the modules scrimage-formats-extra and scrimage-webp .","title":"Input / Output"},{"location":"#image-operations","text":"These operations operate on an image, returning a copy of that image. For instance, fit will resize an image to fit into a specified set of bounds, and scale will change the size of an image. For the full list of operations, see the menu on the left.","title":"Image Operations"},{"location":"#filters","text":"Scrimage comes with a wide array of filters in the module scrimage-filters .","title":"Filters"},{"location":"#composites","text":"","title":"Composites"},{"location":"#metadata","text":"Scrimage builds on the metadata-extractor project to provide the ability to read metadata from an image. Read more details here .","title":"Metadata"},{"location":"#quick-examples","text":"Reading an image, scaling it to 50% using the Bicubic method, and writing out as PNG val in = ... // input stream val out = ... // output stream ImmutableImage . loader (). fromStream ( in ). scale ( 0.5 , Bicubic ). output ( out ) // an implicit PNG writer is in scope by default Reading an image from a java File, applying a blur filter, then flipping it on the horizontal axis, then writing out as a Jpeg val inFile = ... // input File val outFile = ... // output File ImmutableImage . loader (). fromFile ( inFile ). filter ( BlurFilter ). flipX . output ( outFile )( JpegWriter ()) // specified Jpeg Padding an image with a 20 pixel border around the edges in red val in = ... // input stream val out = ... // output stream ImmutableImage . loader (). fromStream ( in ). pad ( 20 , Color . Red ) Enlarging the canvas of an image without scaling the image. Note: the resize methods change the canvas size, and the scale methods are used to scale/resize the actual image. This terminology is consistent with Photoshop. val in = ... // input stream val out = ... // output stream ImmutableImage . loader (). fromStream ( in ). resize ( 600 , 400 ) Scaling an image to a specific size using a fast non-smoothed scale val in = ... // input stream val out = ... // output stream ImmutableImage . loader (). fromStream ( in ). scaleTo ( 300 , 200 , FastScale ) Writing out a heavily compressed Jpeg thumbnail implicit val writer = JpegWriter (). withCompression ( 50 ) val in = ... // input stream val out = ... // output stream ImmutableImage . loader (). fromStream ( in ). fit ( 180 , 120 ). output ( new File ( \"image.jpeg\" )) Printing the sizes and ratio of the image val in = ... // input stream val out = ... // output stream val image = ImmutableImage . loader (). fromStream ( in ) println ( \"Width: ${ image . width } Height: ${ image . height } Ratio: ${ image . ratio } \" ) Converting a byte array in JPEG to a byte array in PNG val in : Array [ Byte ] = ... // array of bytes in JPEG say val out = Image ( in ). write // default is PNG val out2 = ImmutableImage . loader (). fromBytes ( in ). bytes ) // an implicit PNG writer is in scope by default with max compression Coverting an input stream to a PNG with no compression implicit val writer = PngWriter . NoCompression val in : InputStream = ... // some input stream val out = ImmutableImage . loader (). fromStream ( in ). stream","title":"Quick Examples"},{"location":"animated_gif/","text":"Animated GIFs Scrimage supports reading and writing animated GIFs. Reading We read an instance of an AnimatedGif by using the AnimatedGifReader.read method, passing in an ImageSource . The image source can be constructed from files, bytes, input streams and so on. Once we have the animated gif object, we can inspect that to retrieve an ImmutableImage per frame, the total number of frames, delay per frame and so on. Java AnimatedGif gif = AnimatedGifReader . read ( ImageSource . of (...)); ImmutableImage firstFrame = gif . getFrame ( 0 ); ImmutableImage lastFrame = gif . getFrame ( gif . getFrameCount () - 1 ); Kotlin val gif = AnimatedGifReader . read ( ImageSource . of (...)) val firstFrame = gif . frames (). first () val lastFrame = gif . frames (). last () Scala val gif = AnimatedGifReader . read ( ImageSource . of (...)) val firstFrame = gif . frames . head val lastFrame = gif . frames . last Writing Using the StreamingGifWriter class, first we create an instance of the writer, specifying the frame delay (delay between images) and if we should loop. Then we open a stream, specifying either an output path or an output stream, and the AWT image type we want the images to be created with. Java StreamingGifWriter writer = new StreamingGifWriter ( Duration . ofSeconds ( 2 ), true ); GifStream gif = writer . prepareStream ( \"/path/to/gif.gif\" , BufferedImage . TYPE_INT_ARGB ); Kotlin val writer = StreamingGifWriter ( Duration . ofSeconds ( 2 ), true ) val gif = writer . prepareStream ( \"/path/to/gif.gif\" , BufferedImage . TYPE_INT_ARGB ) Scala val writer = new StreamingGifWriter ( Duration . ofSeconds ( 2 ), true ) val gif = writer . prepareStream ( \"/path/to/gif.gif\" , BufferedImage . TYPE_INT_ARGB ) Next we can add as many images as we want, each an instance of an ImmutableImage . Eg, gif.writeFrame(image0); gif.writeFrame(image1); gif.writeFrame(imageN); Finally, we close the stream by invoking finish, and the data is finalized to the output stream or path. gif.finish(); Note Browsers have a minimum frame delay. If you try to set the frame delay lower than the minimum for that browser, the browser will use the default frame delay. The default frame delay is not equal to the minimum . Chrome and Firefox have a minimum frame delay of 0.2 seconds and IE and Safari 0.6 seconds.","title":"Animated Gif"},{"location":"animated_gif/#animated-gifs","text":"Scrimage supports reading and writing animated GIFs.","title":"Animated GIFs"},{"location":"animated_gif/#reading","text":"We read an instance of an AnimatedGif by using the AnimatedGifReader.read method, passing in an ImageSource . The image source can be constructed from files, bytes, input streams and so on. Once we have the animated gif object, we can inspect that to retrieve an ImmutableImage per frame, the total number of frames, delay per frame and so on. Java AnimatedGif gif = AnimatedGifReader . read ( ImageSource . of (...)); ImmutableImage firstFrame = gif . getFrame ( 0 ); ImmutableImage lastFrame = gif . getFrame ( gif . getFrameCount () - 1 ); Kotlin val gif = AnimatedGifReader . read ( ImageSource . of (...)) val firstFrame = gif . frames (). first () val lastFrame = gif . frames (). last () Scala val gif = AnimatedGifReader . read ( ImageSource . of (...)) val firstFrame = gif . frames . head val lastFrame = gif . frames . last","title":"Reading"},{"location":"animated_gif/#writing","text":"Using the StreamingGifWriter class, first we create an instance of the writer, specifying the frame delay (delay between images) and if we should loop. Then we open a stream, specifying either an output path or an output stream, and the AWT image type we want the images to be created with. Java StreamingGifWriter writer = new StreamingGifWriter ( Duration . ofSeconds ( 2 ), true ); GifStream gif = writer . prepareStream ( \"/path/to/gif.gif\" , BufferedImage . TYPE_INT_ARGB ); Kotlin val writer = StreamingGifWriter ( Duration . ofSeconds ( 2 ), true ) val gif = writer . prepareStream ( \"/path/to/gif.gif\" , BufferedImage . TYPE_INT_ARGB ) Scala val writer = new StreamingGifWriter ( Duration . ofSeconds ( 2 ), true ) val gif = writer . prepareStream ( \"/path/to/gif.gif\" , BufferedImage . TYPE_INT_ARGB ) Next we can add as many images as we want, each an instance of an ImmutableImage . Eg, gif.writeFrame(image0); gif.writeFrame(image1); gif.writeFrame(imageN); Finally, we close the stream by invoking finish, and the data is finalized to the output stream or path. gif.finish(); Note Browsers have a minimum frame delay. If you try to set the frame delay lower than the minimum for that browser, the browser will use the default frame delay. The default frame delay is not equal to the minimum . Chrome and Firefox have a minimum frame delay of 0.2 seconds and IE and Safari 0.6 seconds.","title":"Writing"},{"location":"api_intro/","text":"Introduction The core data type in Scrimage is the ImmutableImage class. This wraps a Java AWT image with functions that return copies of the image instead of mutating it. We can create such an instance specifying the dimensions, or we can load an image from one of the supported formats. Once we have an image in memory, we can perform an operation on it that returns a new image. Such as scale , resize , brightness , autocrop and so on. There are pixel functions available, ways to interact with different color namespaces , dozens of filters , or composites . If the underlying source supports it, we can interrogate the associated metadata . Finally, we can save the image back to a file, byte array or stream.","title":"Introduction"},{"location":"api_intro/#introduction","text":"The core data type in Scrimage is the ImmutableImage class. This wraps a Java AWT image with functions that return copies of the image instead of mutating it. We can create such an instance specifying the dimensions, or we can load an image from one of the supported formats. Once we have an image in memory, we can perform an operation on it that returns a new image. Such as scale , resize , brightness , autocrop and so on. There are pixel functions available, ways to interact with different color namespaces , dozens of filters , or composites . If the underlying source supports it, we can interrogate the associated metadata . Finally, we can save the image back to a file, byte array or stream.","title":"Introduction"},{"location":"autocrop/","text":"Autocrop Autocrop is a way of removing excess background on an image. Let's say you had an image that was surrounded by a lot of white background, and you wanted to remove that background so that all that remained was the main image, then autocrop is what you want. It works by checking the pixels of each row and column at the sides, top, and bottom, and working inwards. It removes those rows and columns if they consist entirely of the specified colour. To use, invoke autocrop on an image and pass in the colour to be used as the background detection color. For example to remove excess white background: image . autocrop ( Color . WHITE ) or to remove a background of a custom color you could do: image . autocrop ( new RGBColor ( 255 , 235 , 10 ). awt ()) Examples Using this image as our input: image . autocrop ( new RGBColor ( 255 , 107 , 0 ). awt ())","title":"Autocrop"},{"location":"autocrop/#autocrop","text":"Autocrop is a way of removing excess background on an image. Let's say you had an image that was surrounded by a lot of white background, and you wanted to remove that background so that all that remained was the main image, then autocrop is what you want. It works by checking the pixels of each row and column at the sides, top, and bottom, and working inwards. It removes those rows and columns if they consist entirely of the specified colour. To use, invoke autocrop on an image and pass in the colour to be used as the background detection color. For example to remove excess white background: image . autocrop ( Color . WHITE ) or to remove a background of a custom color you could do: image . autocrop ( new RGBColor ( 255 , 235 , 10 ). awt ())","title":"Autocrop"},{"location":"autocrop/#examples","text":"Using this image as our input: image . autocrop ( new RGBColor ( 255 , 107 , 0 ). awt ())","title":"Examples"},{"location":"benchmarks/","text":"Benchmarks Some noddy benchmarks comparing the speed of rescaling an image. I've compared the basic getScaledInstance method in java.awt.Image with ImgScalr and Scrimage. ImgScalr delegates to awt.Graphics2D for its rendering. Scrimage adapts the methods implemented by Morten Nobel. The code is inside src/test/scala/com/sksamuel/scrimage/ScalingBenchmark.scala. The results are for 100 runs of a resize to a fixed width / height. Library Fast High Quality (Method) java.awt.Image.getScaledInstance 11006ms 17134ms (Area Averaging) ImgScalr 57ms 5018ms (ImgScalr.Quality) Scrimage 113ms 2730ms (Bicubic) As you can see, ImgScalr is the fastest for a simple rescale, but Scrimage is much faster than the rest for a high quality scale.","title":"Benchmarks"},{"location":"benchmarks/#benchmarks","text":"Some noddy benchmarks comparing the speed of rescaling an image. I've compared the basic getScaledInstance method in java.awt.Image with ImgScalr and Scrimage. ImgScalr delegates to awt.Graphics2D for its rendering. Scrimage adapts the methods implemented by Morten Nobel. The code is inside src/test/scala/com/sksamuel/scrimage/ScalingBenchmark.scala. The results are for 100 runs of a resize to a fixed width / height. Library Fast High Quality (Method) java.awt.Image.getScaledInstance 11006ms 17134ms (Area Averaging) ImgScalr 57ms 5018ms (ImgScalr.Quality) Scrimage 113ms 2730ms (Bicubic) As you can see, ImgScalr is the fastest for a simple rescale, but Scrimage is much faster than the rest for a high quality scale.","title":"Benchmarks"},{"location":"blur-and-stretch/","text":"Blur and stretch See this issue Sometimes when you change canvas size of your image you want to use something more fancy than plain solid color as a background. One of possible solutions is to use blurred version of your image as a background. Basically this guide shows one possible way to achieve it using basic Image operations and blur filter ( LensBlurFilter was chosen as an example). You just need to: 1. scale image to desired dimensions to make a foreground, e.g. using scaleToRatio . In code below this step is omitted for simplicity: val fgImage = image 2. scale image using cover and apply some blur via filter to make a background 3. complete process by putting foreground on top of background using overlay import java . nio . file . Paths import com . sksamuel . scrimage .{ Image , ScaleMethod } import com . sksamuel . scrimage . filter . LensBlurFilter val image = Image . fromPath ( Paths . get ( \"examples\" , \"images\" , \"lanzarote_small.jpeg\" )) val filter = new LensBlurFilter ( 12f , 2f , 255f , 10 ) // for simplicity of example source image is not scaled val fgImage = image val targetWidth = fgImage . width * 2 val targetHeight = fgImage . height image . cover ( targetWidth , targetHeight , ScaleMethod . FastScale ) . filter ( filter ) . overlay ( fgImage , x = ( targetWidth - fgImage . width ) / 2 , y = ( targetHeight - fgImage . height ) / 2 ) Compare original and result: Before After","title":"Blur and stretch"},{"location":"blur-and-stretch/#blur-and-stretch","text":"See this issue Sometimes when you change canvas size of your image you want to use something more fancy than plain solid color as a background. One of possible solutions is to use blurred version of your image as a background. Basically this guide shows one possible way to achieve it using basic Image operations and blur filter ( LensBlurFilter was chosen as an example). You just need to: 1. scale image to desired dimensions to make a foreground, e.g. using scaleToRatio . In code below this step is omitted for simplicity: val fgImage = image 2. scale image using cover and apply some blur via filter to make a background 3. complete process by putting foreground on top of background using overlay import java . nio . file . Paths import com . sksamuel . scrimage .{ Image , ScaleMethod } import com . sksamuel . scrimage . filter . LensBlurFilter val image = Image . fromPath ( Paths . get ( \"examples\" , \"images\" , \"lanzarote_small.jpeg\" )) val filter = new LensBlurFilter ( 12f , 2f , 255f , 10 ) // for simplicity of example source image is not scaled val fgImage = image val targetWidth = fgImage . width * 2 val targetHeight = fgImage . height image . cover ( targetWidth , targetHeight , ScaleMethod . FastScale ) . filter ( filter ) . overlay ( fgImage , x = ( targetWidth - fgImage . width ) / 2 , y = ( targetHeight - fgImage . height ) / 2 ) Compare original and result: Before After","title":"Blur and stretch"},{"location":"bound/","text":"Bound Ensures that the image is no larger than specified dimensions. If the source image is larger, it will be scaled down, maintaining aspect ratio . If the source image is smaller, it will be returned unmodified. This is useful when you want to ensure images do not exceed a give size, but you don't want to scale up the image if is already smaller. Examples Using this image scaled to 640 x 360 as our input: Code Output image.bound(400, 300) image.bound(500, 200) image.bound(300, 500)","title":"Bound"},{"location":"bound/#bound","text":"Ensures that the image is no larger than specified dimensions. If the source image is larger, it will be scaled down, maintaining aspect ratio . If the source image is smaller, it will be returned unmodified. This is useful when you want to ensure images do not exceed a give size, but you don't want to scale up the image if is already smaller.","title":"Bound"},{"location":"bound/#examples","text":"Using this image scaled to 640 x 360 as our input: Code Output image.bound(400, 300) image.bound(500, 200) image.bound(300, 500)","title":"Examples"},{"location":"brightness/","text":"Brightness Returns a new Image with the brightness adjusted by the given factor. Examples Using this image as our input: Code Output image.brightness(2.0) image.brightness(0.5)","title":"Brightness"},{"location":"brightness/#brightness","text":"Returns a new Image with the brightness adjusted by the given factor.","title":"Brightness"},{"location":"brightness/#examples","text":"Using this image as our input: Code Output image.brightness(2.0) image.brightness(0.5)","title":"Examples"},{"location":"changelog/","text":"Changelog 4.0.24 Updated StreamingGifWriter to support writing to any OutputStream in addition to the existing file/path options. 4.0.23 Fixed issue with autocrop when no changes are required. 4.0.22 Bumped 12monkeys and commons-io versions. 4.0.21 Added AnimatedGifReader.read(inputstream) , to allow reading each frame of an animated GIF as an ImmutableImage . 4.0.20 Autocrop now works on fully transparent pixels. 4.0.19 All dependencies no longer transitively include kotlin-stdlib. Support webp binary in multiple o/s. 4.0.18 Core dependency no longer transitively includes kotlin-stdlib. 4.0.17 Added withClassloader option to ImmutableImageLoader to support discovery of ImageReader instances on arbitrary classpaths. 4.0.16 Fixed webp support on Windows 4.0.15 Fixed regression in ScaleMethod.Bicubic scale speed. Added ScaleMethod.Progressive scaling method.","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#4024","text":"Updated StreamingGifWriter to support writing to any OutputStream in addition to the existing file/path options.","title":"4.0.24"},{"location":"changelog/#4023","text":"Fixed issue with autocrop when no changes are required.","title":"4.0.23"},{"location":"changelog/#4022","text":"Bumped 12monkeys and commons-io versions.","title":"4.0.22"},{"location":"changelog/#4021","text":"Added AnimatedGifReader.read(inputstream) , to allow reading each frame of an animated GIF as an ImmutableImage .","title":"4.0.21"},{"location":"changelog/#4020","text":"Autocrop now works on fully transparent pixels.","title":"4.0.20"},{"location":"changelog/#4019","text":"All dependencies no longer transitively include kotlin-stdlib. Support webp binary in multiple o/s.","title":"4.0.19"},{"location":"changelog/#4018","text":"Core dependency no longer transitively includes kotlin-stdlib.","title":"4.0.18"},{"location":"changelog/#4017","text":"Added withClassloader option to ImmutableImageLoader to support discovery of ImageReader instances on arbitrary classpaths.","title":"4.0.17"},{"location":"changelog/#4016","text":"Fixed webp support on Windows","title":"4.0.16"},{"location":"changelog/#4015","text":"Fixed regression in ScaleMethod.Bicubic scale speed. Added ScaleMethod.Progressive scaling method.","title":"4.0.15"},{"location":"colors/","text":"Colors Most functions in Scrimage that deal with colours, accept an instance of java.awt.Color, however this class is limited. Scrimage provides its own com.sksamuel.scrimage.color.Color interface with implementations in the following color spaces: RGB CMYK Grayscale HSL HSV Each of these implementations can be converted to the other. For example: new RGBColor(255, 0, 255).toHSV(); or new HSLColor(100f, 0.5f, 0.3f, 1f).toRGB(); When you want to create a colour to pass to a scrimage function, you can convert the Scrimage color type to an AWT color type via the toAwt() method. You can retrieve the average() color value from color . X11 Colors There is a full list of X11 defined colors in the X11Colorlist class. These can be used and converted to an AWT Color when you need more than the defaults built into the JDK. For example, to copy an image, setting all pixels to misty rose , we can use the following code: image.fill(X11Colorlist.MistyRose.awt())","title":"Colors"},{"location":"colors/#colors","text":"Most functions in Scrimage that deal with colours, accept an instance of java.awt.Color, however this class is limited. Scrimage provides its own com.sksamuel.scrimage.color.Color interface with implementations in the following color spaces: RGB CMYK Grayscale HSL HSV Each of these implementations can be converted to the other. For example: new RGBColor(255, 0, 255).toHSV(); or new HSLColor(100f, 0.5f, 0.3f, 1f).toRGB(); When you want to create a colour to pass to a scrimage function, you can convert the Scrimage color type to an AWT color type via the toAwt() method. You can retrieve the average() color value from color .","title":"Colors"},{"location":"colors/#x11-colors","text":"There is a full list of X11 defined colors in the X11Colorlist class. These can be used and converted to an AWT Color when you need more than the defaults built into the JDK. For example, to copy an image, setting all pixels to misty rose , we can use the following code: image.fill(X11Colorlist.MistyRose.awt())","title":"X11 Colors"},{"location":"composites/","text":"Composites Scrimage comes with several composites. A composite merges two images with each pixel composited together using the rule provided by the composite class. This grid shows the effect of compositing a palm tree image over a US mailbox image. The first column is the composite with a value of 0.5f, and the second column with 1f. Note, if you reverse the order of the images then the effects would be reversed. The code required to perform a composite is simple: Java ImmutableImage composed = image1.composite(new XYZComposite(alpha), image2) Kotlin val composed = image1.composite(XYZComposite(alpha), image2) Scala val composed = image1.composite(new XYZComposite(alpha), image2) Click on an example to see it full screen. Composite Alpha 0.5f Alpha 1f average blue color colorburn colordodge diff green grow hue hard heat lighten negation luminosity multiply negation normal overlay red reflect saturation screen subtract","title":"Composites"},{"location":"composites/#composites","text":"Scrimage comes with several composites. A composite merges two images with each pixel composited together using the rule provided by the composite class. This grid shows the effect of compositing a palm tree image over a US mailbox image. The first column is the composite with a value of 0.5f, and the second column with 1f. Note, if you reverse the order of the images then the effects would be reversed. The code required to perform a composite is simple: Java ImmutableImage composed = image1.composite(new XYZComposite(alpha), image2) Kotlin val composed = image1.composite(XYZComposite(alpha), image2) Scala val composed = image1.composite(new XYZComposite(alpha), image2) Click on an example to see it full screen. Composite Alpha 0.5f Alpha 1f average blue color colorburn colordodge diff green grow hue hard heat lighten negation luminosity multiply negation normal overlay red reflect saturation screen subtract","title":"Composites"},{"location":"contrast/","text":"Contrast Returns a new image with the contrast adjusted by the given factor. Examples Using this image as our input: image . contrast ( 2.0 ) image . contrast ( 0.5 )","title":"Contrast"},{"location":"contrast/#contrast","text":"Returns a new image with the contrast adjusted by the given factor.","title":"Contrast"},{"location":"contrast/#examples","text":"Using this image as our input: image . contrast ( 2.0 ) image . contrast ( 0.5 )","title":"Examples"},{"location":"cover/","text":"Cover The cover operation creates an image with the specified dimensions, with the original image scaled to cover the whole canvas, such that there is no added \"background\". If the source and target dimensions do not have the same aspect ratio then part of the source image will be lost as it will have to be \"over scaled\" to completely cover the target image. This is similar to taking a 16:9 movie and resizing it for a 4:3 screen. You can either lose part of the image (this operation) or resize it so there is empty space on two sides (the fit operation). Compare this operation with fit . To use, invoke with the target dimensions and optionally, a scale method (defaults to ScaleMethod.Bicubic), and the position of the source image in the target (defaults to Position.Center). That last parameter has no effect if the aspect ratios are the same, since the image will cover the target without any loss. Examples Using this image scaled to 640 x 360 as our input: image . cover ( 400 , 300 ) image . cover ( 500 , 200 ) image . cover ( 500 , 200 , Position . TopLeft ) image . cover ( 400 , 400 ) image . cover ( 400 , 400 , Position . CenterRight )","title":"Cover"},{"location":"cover/#cover","text":"The cover operation creates an image with the specified dimensions, with the original image scaled to cover the whole canvas, such that there is no added \"background\". If the source and target dimensions do not have the same aspect ratio then part of the source image will be lost as it will have to be \"over scaled\" to completely cover the target image. This is similar to taking a 16:9 movie and resizing it for a 4:3 screen. You can either lose part of the image (this operation) or resize it so there is empty space on two sides (the fit operation). Compare this operation with fit . To use, invoke with the target dimensions and optionally, a scale method (defaults to ScaleMethod.Bicubic), and the position of the source image in the target (defaults to Position.Center). That last parameter has no effect if the aspect ratios are the same, since the image will cover the target without any loss.","title":"Cover"},{"location":"cover/#examples","text":"Using this image scaled to 640 x 360 as our input: image . cover ( 400 , 300 ) image . cover ( 500 , 200 ) image . cover ( 500 , 200 , Position . TopLeft ) image . cover ( 400 , 400 ) image . cover ( 400 , 400 , Position . CenterRight )","title":"Examples"},{"location":"create/","text":"Create There are a couple of ways to create a completely empty image. The first is with the create static method on ImmutableImage . This allows us to specify the width, height and optionally the AWT image type (eg 4 byte ARGB). For example, // defaults to TYPE_INT_ARGB ImmutableImage . create ( 400 , 300 ) // specifying the image type ImmutableImage . create ( 400 , 300 , BufferedImage . TYPE_4BYTE_ABGR ) Another way to create an image, is to call blank on an existing image. This will return a new image with the same type and size and an uninitialized raster. image . blank () Finally, copy allows us to copy an existing image, with each pixel copied. This function allows us to specify the type of the copy as well. // copy with the data duplicated image . copy () // copy with the data duplicated, and the raster using the specified type ImmutableImage . copy ( BufferedImage . TYPE_4BYTE_ABGR )","title":"Creating an image"},{"location":"create/#create","text":"There are a couple of ways to create a completely empty image. The first is with the create static method on ImmutableImage . This allows us to specify the width, height and optionally the AWT image type (eg 4 byte ARGB). For example, // defaults to TYPE_INT_ARGB ImmutableImage . create ( 400 , 300 ) // specifying the image type ImmutableImage . create ( 400 , 300 , BufferedImage . TYPE_4BYTE_ABGR ) Another way to create an image, is to call blank on an existing image. This will return a new image with the same type and size and an uninitialized raster. image . blank () Finally, copy allows us to copy an existing image, with each pixel copied. This function allows us to specify the type of the copy as well. // copy with the data duplicated image . copy () // copy with the data duplicated, and the raster using the specified type ImmutableImage . copy ( BufferedImage . TYPE_4BYTE_ABGR )","title":"Create"},{"location":"extra_formats/","text":"Formats-Extra Scrimage provides for support for many common formats outside the standard Java ImageIO classes via an optional module. The scrimage-formats-extra module brings in additional formats such as PCX, BMP, TGA and more. It also includes a better TIFF reader than the one available in the standard java library and a customizable TIFF writer. To read from these formats, just add the module to your classpath, nothing more. To write using these formats, pass an instance of the applicable ImageWriter interface when saving out the format. For example, image . output ( new BmpWriter (), new File ( \"output.bmp\" )) or image . output ( new PcxWriter (), new File ( \"output.pcx\" ))","title":"Extra Formats"},{"location":"extra_formats/#formats-extra","text":"Scrimage provides for support for many common formats outside the standard Java ImageIO classes via an optional module. The scrimage-formats-extra module brings in additional formats such as PCX, BMP, TGA and more. It also includes a better TIFF reader than the one available in the standard java library and a customizable TIFF writer. To read from these formats, just add the module to your classpath, nothing more. To write using these formats, pass an instance of the applicable ImageWriter interface when saving out the format. For example, image . output ( new BmpWriter (), new File ( \"output.bmp\" )) or image . output ( new PcxWriter (), new File ( \"output.pcx\" ))","title":"Formats-Extra"},{"location":"fill/","text":"Fill Creates a new image with the same dimensions as a source image, setting each pixel to the specified colour. In addition to the colour, the function accepts a Painter which can be used to apply a gradient. Examples Using this image as our input: // a new image with all pixels blue, and the dimensions // taken from the source image image . fill ( Color . BLUE ) // a new image with the pixels coloured from the given vertical gradient. image . fill ( LinearGradient . vertical ( Color . BLACK , Color . WHITE )) // a new image with the pixels coloured from the given horizontal gradient image . fill ( LinearGradient . horizontal ( Color . BLACK , Color . WHITE ))","title":"Fill"},{"location":"fill/#fill","text":"Creates a new image with the same dimensions as a source image, setting each pixel to the specified colour. In addition to the colour, the function accepts a Painter which can be used to apply a gradient.","title":"Fill"},{"location":"fill/#examples","text":"Using this image as our input: // a new image with all pixels blue, and the dimensions // taken from the source image image . fill ( Color . BLUE ) // a new image with the pixels coloured from the given vertical gradient. image . fill ( LinearGradient . vertical ( Color . BLACK , Color . WHITE )) // a new image with the pixels coloured from the given horizontal gradient image . fill ( LinearGradient . horizontal ( Color . BLACK , Color . WHITE ))","title":"Examples"},{"location":"filters/","text":"Filters Scrimage comes with a wide array of filters. A filter modifies the pixels of an image in some pre-determined way. For example, a simple filter might reduce the brightness of each pixel by 50%. Most of these filters I have not written myself, but rather collected from other open source imaging libraries (for compliance with licenses and / or attribution - see file headers), and either wrapped them, fixed bugs or improved them. !!! note These filters require the scrimage-filters module to be added to your build. Applying a filter returns a new image. The original image is unmodified. Some filters have options which can be set when creating the filters. All filters are immutable. Most filters have sensible default options as default parameters. To apply a filter, we just use the filter method on an image, for example: Java ImmutableImage filtered = image.filter(new DitherFilter()) Kotlin val filtered = image.filter(DitherFilter()) Scala val filtered = image.composite(new DitherFilter()) Click on the small images to see an enlarged example. Filter Example 1 Example 2 Example 3 black_threshold blur border brightness bump caption chrome color_halftone colorize contour contrast crystallize despeckle diffuse dither edge emboss error_diffusion_halftone gain_bias gamma gaussian glow gotham grayscale hsb invert_alpha invert kaleidoscope lensblur lensflare minimum maximum motionblur nashville noise offset oil old_photo opacity pixelate pointillize_square posterize prewitt quantize rays rgb ripple roberts rylanders sepia sharpen smear_circles snow sobels solarize sparkle summer swim television threshold tritone twirl unsharp vignette vintage watermark_cover watermark_stamp","title":"Filters"},{"location":"filters/#filters","text":"Scrimage comes with a wide array of filters. A filter modifies the pixels of an image in some pre-determined way. For example, a simple filter might reduce the brightness of each pixel by 50%. Most of these filters I have not written myself, but rather collected from other open source imaging libraries (for compliance with licenses and / or attribution - see file headers), and either wrapped them, fixed bugs or improved them. !!! note These filters require the scrimage-filters module to be added to your build. Applying a filter returns a new image. The original image is unmodified. Some filters have options which can be set when creating the filters. All filters are immutable. Most filters have sensible default options as default parameters. To apply a filter, we just use the filter method on an image, for example: Java ImmutableImage filtered = image.filter(new DitherFilter()) Kotlin val filtered = image.filter(DitherFilter()) Scala val filtered = image.composite(new DitherFilter()) Click on the small images to see an enlarged example. Filter Example 1 Example 2 Example 3 black_threshold blur border brightness bump caption chrome color_halftone colorize contour contrast crystallize despeckle diffuse dither edge emboss error_diffusion_halftone gain_bias gamma gaussian glow gotham grayscale hsb invert_alpha invert kaleidoscope lensblur lensflare minimum maximum motionblur nashville noise offset oil old_photo opacity pixelate pointillize_square posterize prewitt quantize rays rgb ripple roberts rylanders sepia sharpen smear_circles snow sobels solarize sparkle summer swim television threshold tritone twirl unsharp vignette vintage watermark_cover watermark_stamp","title":"Filters"},{"location":"fit/","text":"Fit The fit operation creates an image with the specified dimensions, with the original image scaled to fit exactly inside, as large as possible, without losing any of the original image. If the source and target dimensions do not have the same aspect ratio then the original image will not cover the entire output image, so the excess background is set to a default color. The difference between this and max , is that fit will pad out the canvas to the specified dimensions, whereas max will not. In other words, max and fit will result an equal amount of scaling, but fit will pad the canvas with a background color so that it precisely matches the input dimensions. The difference between this and cover is that cover will also return an image with the specified dimensions, but will size the image to ensure there is no background padding required, but potentially losing some of the source image. To use, invoke with the target dimenions and optionally, a background color (defaults to Color.WHITE), a scale method (defaults to ScaleMethod.Bicubic), and the position of the source image in the target (defaults to Position.Center). That last parameter has no effect if the aspect ratios are the same (because in that case the image would fit exactly inside anyway). Examples Using this image scaled to 640 x 360 as our input: Code Output image.fit(400, 300, Color.DARK_GRAY) image.fit(300, 300, Color.BLUE) image.fit(400, 100, Color.RED)","title":"Fit"},{"location":"fit/#fit","text":"The fit operation creates an image with the specified dimensions, with the original image scaled to fit exactly inside, as large as possible, without losing any of the original image. If the source and target dimensions do not have the same aspect ratio then the original image will not cover the entire output image, so the excess background is set to a default color. The difference between this and max , is that fit will pad out the canvas to the specified dimensions, whereas max will not. In other words, max and fit will result an equal amount of scaling, but fit will pad the canvas with a background color so that it precisely matches the input dimensions. The difference between this and cover is that cover will also return an image with the specified dimensions, but will size the image to ensure there is no background padding required, but potentially losing some of the source image. To use, invoke with the target dimenions and optionally, a background color (defaults to Color.WHITE), a scale method (defaults to ScaleMethod.Bicubic), and the position of the source image in the target (defaults to Position.Center). That last parameter has no effect if the aspect ratios are the same (because in that case the image would fit exactly inside anyway).","title":"Fit"},{"location":"fit/#examples","text":"Using this image scaled to 640 x 360 as our input: Code Output image.fit(400, 300, Color.DARK_GRAY) image.fit(300, 300, Color.BLUE) image.fit(400, 100, Color.RED)","title":"Examples"},{"location":"flip/","text":"Flip Flips the image either horizontally or vertically. Examples Using this image scaled to 640 x 360 as our input: Code Output image.flipX() image.flipY()","title":"Flip"},{"location":"flip/#flip","text":"Flips the image either horizontally or vertically.","title":"Flip"},{"location":"flip/#examples","text":"Using this image scaled to 640 x 360 as our input: Code Output image.flipX() image.flipY()","title":"Examples"},{"location":"format_detection/","text":"Format Detection If you are interested in detecting the format of an image (which you don't need to do when simply loading an image, as Scrimage will figure it out for you) then you can use the FormatDetector . The detector recognises PNG, JPEG and GIF. This method does not need to load all bytes, only the initial few bytes to determine what the format is. The return value is an Optional with the detected format, or a None if unable to detect. // detect from a byte array FormatDetector . detect ( bytes ) // detect from an input stream FormatDetector . detect ( inputStream )","title":"Format Detection"},{"location":"format_detection/#format-detection","text":"If you are interested in detecting the format of an image (which you don't need to do when simply loading an image, as Scrimage will figure it out for you) then you can use the FormatDetector . The detector recognises PNG, JPEG and GIF. This method does not need to load all bytes, only the initial few bytes to determine what the format is. The return value is an Optional with the detected format, or a None if unable to detect. // detect from a byte array FormatDetector . detect ( bytes ) // detect from an input stream FormatDetector . detect ( inputStream )","title":"Format Detection"},{"location":"io/","text":"Reading / Writing Scrimage supports loading and saving of images in the common web formats (png, jpeg, gif, tiff, webp). In addition, it extends javas image.io support by giving you an easy way to set options on the output format when saving. Warning The TIFF support via javax.imageio has issues with some tiff images. If this happens, try using the scrimage-formats-extra module which provides extra TIFF support via the TwelveMonkeys library . Reading To load an image we use the ImmutableImageLoader interface. An instance can be created via ImmutableImage.loader() . This allows us to customize loading behavior and specify the input source. Supported sources are input streams, byte arrays, files, paths, classpath resources or anything that implements the ImageSource interface. For example, to load an image from the filesystem: Java ImmutableImage image = ImmutableImage . loader (). fromFile ( file ); Kotlin val image = ImmutableImage . loader (). fromFile ( file ) Scala val image = ImmutableImage . loader (). fromFile ( file ) or to load from a byte array: Java ImmutableImage image = ImmutableImage . loader (). fromBytes ( bytes ); Kotlin val image = ImmutableImage . loader (). fromBytes ( bytes ) Scala val image = ImmutableImage . loader (). fromBytes ( bytes ) We can load from byte arrays, streams, files, paths, resources and so on. Image loader options The ImmutableImageLoader has several options to customize loading. Option Description detectOrientation If set to true (the default) then if the image has metadata that indeeds its orientation, then scrimage will rotate the image back to landscape detectMetadata If set to true (the default) then scrimage will attempt to parse the metadata tags (if any) present in the file type Sets the BufferedImage type that the loaded image should use. If unspecified then the default of the reader implementation is used sourceRegion Sets an area to load from the image. If you are loading an image to immediately crop, then this operation can result in less bytes being read from the source Writing To save a method, Scrimage requires an ImageWriter for the format you wish to persist to. Some programs use the filename extension to infer, but with Scrimage you must specify it. For example, to save an image as a PNG: Java ImmutableImage image = ... // some image // write out to a file image . output ( PngWriter . Default , new File ( \"/home/sam/spaghetti.png\" )); Kotlin val image = ... // some image // write out to a file image . output ( PngWriter . Default , File ( \"/home/sam/spaghetti.png\" )) Scala val image = ... // some image // write out to a file image . output ( PngWriter . Default , new File ( \"/home/sam/spaghetti.png\" )) If you want to override the configuration for a writer then you can do this when you create the writer. For example to save a JPEG with 50% compression: Java JpegWriter writer = new JpegWriter (). withCompression ( 50 ). withProgressive ( true ); image . output ( writer , new File ( \"/home/sam/spaghetti.png\" )); Kotlin val writer = JpegWriter (). withCompression ( 50 ). withProgressive ( true ) image . output ( writer , File ( \"/home/sam/spaghetti.png\" )) Scala val writer = new JpegWriter (). withCompression ( 50 ). withProgressive ( true ) image . output ( writer , new File ( \"/home/sam/spaghetti.png\" )) Supported Writers The available writers along with supported options are: Writer Option Description JpegWriter compression Set to between 0 (full lossy compression) and 100 (full quality / no compression) progressive If true then data is compressed in multiple passes of progressively higher detail PngWriter compression Set to a value between 0 (no compression) and 9 (max compression). Compression in PNG is lossless GifWriter progressive If true then data is compressed in multiple passes of progressively higher detail","title":"Reading/Writing"},{"location":"io/#reading-writing","text":"Scrimage supports loading and saving of images in the common web formats (png, jpeg, gif, tiff, webp). In addition, it extends javas image.io support by giving you an easy way to set options on the output format when saving. Warning The TIFF support via javax.imageio has issues with some tiff images. If this happens, try using the scrimage-formats-extra module which provides extra TIFF support via the TwelveMonkeys library .","title":"Reading / Writing"},{"location":"io/#reading","text":"To load an image we use the ImmutableImageLoader interface. An instance can be created via ImmutableImage.loader() . This allows us to customize loading behavior and specify the input source. Supported sources are input streams, byte arrays, files, paths, classpath resources or anything that implements the ImageSource interface. For example, to load an image from the filesystem: Java ImmutableImage image = ImmutableImage . loader (). fromFile ( file ); Kotlin val image = ImmutableImage . loader (). fromFile ( file ) Scala val image = ImmutableImage . loader (). fromFile ( file ) or to load from a byte array: Java ImmutableImage image = ImmutableImage . loader (). fromBytes ( bytes ); Kotlin val image = ImmutableImage . loader (). fromBytes ( bytes ) Scala val image = ImmutableImage . loader (). fromBytes ( bytes ) We can load from byte arrays, streams, files, paths, resources and so on.","title":"Reading"},{"location":"io/#image-loader-options","text":"The ImmutableImageLoader has several options to customize loading. Option Description detectOrientation If set to true (the default) then if the image has metadata that indeeds its orientation, then scrimage will rotate the image back to landscape detectMetadata If set to true (the default) then scrimage will attempt to parse the metadata tags (if any) present in the file type Sets the BufferedImage type that the loaded image should use. If unspecified then the default of the reader implementation is used sourceRegion Sets an area to load from the image. If you are loading an image to immediately crop, then this operation can result in less bytes being read from the source","title":"Image loader options"},{"location":"io/#writing","text":"To save a method, Scrimage requires an ImageWriter for the format you wish to persist to. Some programs use the filename extension to infer, but with Scrimage you must specify it. For example, to save an image as a PNG: Java ImmutableImage image = ... // some image // write out to a file image . output ( PngWriter . Default , new File ( \"/home/sam/spaghetti.png\" )); Kotlin val image = ... // some image // write out to a file image . output ( PngWriter . Default , File ( \"/home/sam/spaghetti.png\" )) Scala val image = ... // some image // write out to a file image . output ( PngWriter . Default , new File ( \"/home/sam/spaghetti.png\" )) If you want to override the configuration for a writer then you can do this when you create the writer. For example to save a JPEG with 50% compression: Java JpegWriter writer = new JpegWriter (). withCompression ( 50 ). withProgressive ( true ); image . output ( writer , new File ( \"/home/sam/spaghetti.png\" )); Kotlin val writer = JpegWriter (). withCompression ( 50 ). withProgressive ( true ) image . output ( writer , File ( \"/home/sam/spaghetti.png\" )) Scala val writer = new JpegWriter (). withCompression ( 50 ). withProgressive ( true ) image . output ( writer , new File ( \"/home/sam/spaghetti.png\" ))","title":"Writing"},{"location":"io/#supported-writers","text":"The available writers along with supported options are: Writer Option Description JpegWriter compression Set to between 0 (full lossy compression) and 100 (full quality / no compression) progressive If true then data is compressed in multiple passes of progressively higher detail PngWriter compression Set to a value between 0 (no compression) and 9 (max compression). Compression in PNG is lossless GifWriter progressive If true then data is compressed in multiple passes of progressively higher detail","title":"Supported Writers"},{"location":"max/","text":"Max Scales an image to be as large as possible to fit into the specified dimensions whilst maintaining aspect ratio. This operation will not pad the image to ensure it matches the dimensions exactly. For example, starting with an image that is 300x200 and invoking max(420,300) will result in an image that is 420x280, because that is as large as the image can be without exceeding the required dimensions. Similarly, starting with 600x400 and invoking max(400,100) will result in an image that is 150x100. The difference between max and fit , is that fit will pad out the canvas to the specified dimensions, whereas max will not. In other words, max and fit will scale the image equally, but fit will pad the canvas with a background color so that it precisely matches the input dimensions. Examples Using this image scaled to 640 x 360 as our input: Code Output image.max(400, 300) image.max(300, 300) image.max(200, 400)","title":"Max"},{"location":"max/#max","text":"Scales an image to be as large as possible to fit into the specified dimensions whilst maintaining aspect ratio. This operation will not pad the image to ensure it matches the dimensions exactly. For example, starting with an image that is 300x200 and invoking max(420,300) will result in an image that is 420x280, because that is as large as the image can be without exceeding the required dimensions. Similarly, starting with 600x400 and invoking max(400,100) will result in an image that is 150x100. The difference between max and fit , is that fit will pad out the canvas to the specified dimensions, whereas max will not. In other words, max and fit will scale the image equally, but fit will pad the canvas with a background color so that it precisely matches the input dimensions.","title":"Max"},{"location":"max/#examples","text":"Using this image scaled to 640 x 360 as our input: Code Output image.max(400, 300) image.max(300, 300) image.max(200, 400)","title":"Examples"},{"location":"metadata/","text":"Metadata Scrimage builds on the metadata-extractor project to provide the ability to read metadata. This can be done in two ways. Firstly, the metadata is attached to the image if it was available when you loaded the image from the a stream, file or resource. Then you can call image.metadata to get a handle to the metadata object. Secondly, the metadata can be loaded without needing to create an image instance, by using the methods on ImageMetadata . Once you have the metadata object, you can invoke directories or tags to see the information. For example, we can print out all the tags in an image via this code: Java ImageMetadata meta = ImageMetadata.fromStream(stream); Arrays.stream(meta.tags()).forEach(tag -> System.out.println(tag)); Kotlin val meta = ImageMetadata.fromStream(stream) meta.tags().forEach { println(it) } Scala val meta = ImageMetadata.fromStream(stream) meta.tags().asScala.foreach { tag => println(tag) } And the output will look something like: ... Tag{name='Compression Type', type=-3, rawValue='0', value='Baseline'} Tag{name='Data Precision', type=0, rawValue='8', value='8 bits'} Tag{name='Image Height', type=1, rawValue='405', value='405 pixels'} Tag{name='Image Width', type=3, rawValue='594', value='594 pixels'} Tag{name='Resolution Units', type=7, rawValue='1', value='inch'} Tag{name='X Resolution', type=8, rawValue='300', value='300 dots'} Tag{name='Y Resolution', type=10, rawValue='300', value='300 dots'} Tag{name='Thumbnail Width Pixels', type=12, rawValue='0', value='0'} Tag{name='Thumbnail Height Pixels', type=13, rawValue='0', value='0'} Tag{name='Image Width', type=256, rawValue='4928', value='4928 pixels'} Tag{name='Image Height', type=257, rawValue='3280', value='3280 pixels'} Tag{name='Bits Per Sample', type=258, rawValue='8 8 8', value='8 8 8 bits/component/pixel'} Tag{name='Photometric Interpretation', type=262, rawValue='2', value='RGB'} Tag{name='Image Description', type=270, rawValue='during the Sky Bet Championship match between Middlesbrough and Wolverhampton Wanderers at Riverside Stadium on April 14, 2015 in Middlesbrough, England.', value='during the Sky Bet Championship match between Middlesbrough and Wolverhampton Wanderers at Riverside Stadium on April 14, 2015 in Middlesbrough, England.'} Tag{name='Make', type=271, rawValue='NIKON CORPORATION', value='NIKON CORPORATION'} Tag{name='Model', type=272, rawValue='NIKON D4S', value='NIKON D4S'} Tag{name='Orientation', type=274, rawValue='1', value='Top, left side (Horizontal / normal)'} Tag{name='Samples Per Pixel', type=277, rawValue='3', value='3 samples/pixel'} Tag{name='X Resolution', type=282, rawValue='72', value='72 dots per inch'} Tag{name='Y Resolution', type=283, rawValue='72', value='72 dots per inch'} ... Orientation The orientation tag is a commonly used tag, so there is a function to specifically retrieve this, if defined (sometimes, eg on Sony cameras, it is defined more than once!). These helper methods are found in the OrientationTools class. For example: OrientationTools.imageOrientationsOf(image.metadata);","title":"Metadata"},{"location":"metadata/#metadata","text":"Scrimage builds on the metadata-extractor project to provide the ability to read metadata. This can be done in two ways. Firstly, the metadata is attached to the image if it was available when you loaded the image from the a stream, file or resource. Then you can call image.metadata to get a handle to the metadata object. Secondly, the metadata can be loaded without needing to create an image instance, by using the methods on ImageMetadata . Once you have the metadata object, you can invoke directories or tags to see the information. For example, we can print out all the tags in an image via this code: Java ImageMetadata meta = ImageMetadata.fromStream(stream); Arrays.stream(meta.tags()).forEach(tag -> System.out.println(tag)); Kotlin val meta = ImageMetadata.fromStream(stream) meta.tags().forEach { println(it) } Scala val meta = ImageMetadata.fromStream(stream) meta.tags().asScala.foreach { tag => println(tag) } And the output will look something like: ... Tag{name='Compression Type', type=-3, rawValue='0', value='Baseline'} Tag{name='Data Precision', type=0, rawValue='8', value='8 bits'} Tag{name='Image Height', type=1, rawValue='405', value='405 pixels'} Tag{name='Image Width', type=3, rawValue='594', value='594 pixels'} Tag{name='Resolution Units', type=7, rawValue='1', value='inch'} Tag{name='X Resolution', type=8, rawValue='300', value='300 dots'} Tag{name='Y Resolution', type=10, rawValue='300', value='300 dots'} Tag{name='Thumbnail Width Pixels', type=12, rawValue='0', value='0'} Tag{name='Thumbnail Height Pixels', type=13, rawValue='0', value='0'} Tag{name='Image Width', type=256, rawValue='4928', value='4928 pixels'} Tag{name='Image Height', type=257, rawValue='3280', value='3280 pixels'} Tag{name='Bits Per Sample', type=258, rawValue='8 8 8', value='8 8 8 bits/component/pixel'} Tag{name='Photometric Interpretation', type=262, rawValue='2', value='RGB'} Tag{name='Image Description', type=270, rawValue='during the Sky Bet Championship match between Middlesbrough and Wolverhampton Wanderers at Riverside Stadium on April 14, 2015 in Middlesbrough, England.', value='during the Sky Bet Championship match between Middlesbrough and Wolverhampton Wanderers at Riverside Stadium on April 14, 2015 in Middlesbrough, England.'} Tag{name='Make', type=271, rawValue='NIKON CORPORATION', value='NIKON CORPORATION'} Tag{name='Model', type=272, rawValue='NIKON D4S', value='NIKON D4S'} Tag{name='Orientation', type=274, rawValue='1', value='Top, left side (Horizontal / normal)'} Tag{name='Samples Per Pixel', type=277, rawValue='3', value='3 samples/pixel'} Tag{name='X Resolution', type=282, rawValue='72', value='72 dots per inch'} Tag{name='Y Resolution', type=283, rawValue='72', value='72 dots per inch'} ...","title":"Metadata"},{"location":"metadata/#orientation","text":"The orientation tag is a commonly used tag, so there is a function to specifically retrieve this, if defined (sometimes, eg on Sony cameras, it is defined more than once!). These helper methods are found in the OrientationTools class. For example: OrientationTools.imageOrientationsOf(image.metadata);","title":"Orientation"},{"location":"orientation/","text":"Orientation Apple iPhone's have this annoying \"feature\" where an image taken when the phone is rotated is not saved as a rotated file. Instead the image is always saved as landscape with a flag set to whether it was portrait or not. Scrimage will detect this flag, if it is present on the file, and correct the orientation for you automatically. Most image readers do this, such as web browsers, but you might have noticed some things do not, such as intellij. Note: This can be disabled by setting detectOrientation(false) on the ImmutableImage.loader() instance.","title":"Orientation"},{"location":"orientation/#orientation","text":"Apple iPhone's have this annoying \"feature\" where an image taken when the phone is rotated is not saved as a rotated file. Instead the image is always saved as landscape with a flag set to whether it was portrait or not. Scrimage will detect this flag, if it is present on the file, and correct the orientation for you automatically. Most image readers do this, such as web browsers, but you might have noticed some things do not, such as intellij. Note: This can be disabled by setting detectOrientation(false) on the ImmutableImage.loader() instance.","title":"Orientation"},{"location":"overlay/","text":"Overlay Returns a new image which is the original image plus a specified image overlaid on top. The overlaying image is placed at an offset starting at 0,0 at the top left. A negative offset will start the image \"off canvas\". Any excess pixels from the overlay image are ignored. For example, if the overlay image is too large, or overlaps. Examples Using these images as our input: image . overlay ( picard , 25 , 25 ) image . overlay ( picard , - 75 , 0 )","title":"Overlay"},{"location":"overlay/#overlay","text":"Returns a new image which is the original image plus a specified image overlaid on top. The overlaying image is placed at an offset starting at 0,0 at the top left. A negative offset will start the image \"off canvas\". Any excess pixels from the overlay image are ignored. For example, if the overlay image is too large, or overlaps.","title":"Overlay"},{"location":"overlay/#examples","text":"Using these images as our input: image . overlay ( picard , 25 , 25 ) image . overlay ( picard , - 75 , 0 )","title":"Examples"},{"location":"pad/","text":"Pad Resizes the canvas by adding a number of pixels around the edges in a given color. This is the opposite of the trim operation. Pad can add pixels uniformly around all edges using pad(k) or on a specified edge only, using padLeft(k) and so on. Examples Using this image as our input: image . scale ( 0.5 ) . pad ( 10 , Color . DARK_GRAY ) image . scale ( 0.5 ) . padRight ( 25 , Color . BLUE ) . padBottom ( 40 , Color . RED )","title":"Pad"},{"location":"pad/#pad","text":"Resizes the canvas by adding a number of pixels around the edges in a given color. This is the opposite of the trim operation. Pad can add pixels uniformly around all edges using pad(k) or on a specified edge only, using padLeft(k) and so on.","title":"Pad"},{"location":"pad/#examples","text":"Using this image as our input: image . scale ( 0.5 ) . pad ( 10 , Color . DARK_GRAY ) image . scale ( 0.5 ) . padRight ( 25 , Color . BLUE ) . padBottom ( 40 , Color . RED )","title":"Examples"},{"location":"pixels/","text":"Pixel Functions There are several functions available on ImmutableImage that operate at the pixel level. To return all pixels in an image, we can use image.argb() or image.pixels() . The former returns pixels as ARGB integer encodings, and the latter returns them as Pixel objects. image.pixel(x,y) returns the pixel at the given coordinates and count() returns the total number of pixels in the image. If we want to count the number of pixels that satisfy a predicate, we can use the version of count that accepts a function. // count number of pixels with some blue image . count ( pixel -> pixel . blue () > 0 ) If you wish to run a side-effecting function for every pixel, then use forEach . image . forEach ( pixel -> { if ( pixel . blue () == 255 ) { System . out . println ( \"Is totally blue man!\" ); } }); If you want to return a new image, mapping each pixel to another colour, then use map . // remove all blue image . map ( pixel -> new RGBColor ( pixel . red (), pixel . green (), 0 ). awt ()); If you wish to check an image to see if at least one pixel satisfies a predicate, then use exists . // returns true if any pixel has some blue image . exists ( pixel -> pixel . blue () > 0 ); If you wish to run a predicate against every pixel, and return true if all pixels satisfy that predicate, then use forAll . // returns true if all pixels have some blue image . forAll ( pixel -> pixel . blue () > 0 );","title":"Pixel Functions"},{"location":"pixels/#pixel-functions","text":"There are several functions available on ImmutableImage that operate at the pixel level. To return all pixels in an image, we can use image.argb() or image.pixels() . The former returns pixels as ARGB integer encodings, and the latter returns them as Pixel objects. image.pixel(x,y) returns the pixel at the given coordinates and count() returns the total number of pixels in the image. If we want to count the number of pixels that satisfy a predicate, we can use the version of count that accepts a function. // count number of pixels with some blue image . count ( pixel -> pixel . blue () > 0 ) If you wish to run a side-effecting function for every pixel, then use forEach . image . forEach ( pixel -> { if ( pixel . blue () == 255 ) { System . out . println ( \"Is totally blue man!\" ); } }); If you want to return a new image, mapping each pixel to another colour, then use map . // remove all blue image . map ( pixel -> new RGBColor ( pixel . red (), pixel . green (), 0 ). awt ()); If you wish to check an image to see if at least one pixel satisfies a predicate, then use exists . // returns true if any pixel has some blue image . exists ( pixel -> pixel . blue () > 0 ); If you wish to run a predicate against every pixel, and return true if all pixels satisfy that predicate, then use forAll . // returns true if all pixels have some blue image . forAll ( pixel -> pixel . blue () > 0 );","title":"Pixel Functions"},{"location":"quick_start/","text":"Including Scrimage in your project Scrimage is available on maven central. There are several modules. One is the scrimage-core library which is required. The others are scrimage-filters , scrimage-formats-extra , scrimage-webp . And if you're using Scala you can also add scrimage-scala_2.12 or scrimage-scala_2.13 for enhanced scala functions. They are split into several modules because the image filters is a large jar, and most people just want the basic resize/scale/load/save functionality. The scrimage-formats-extra package brings in readers/writers for less common formats such as BMP, Tiff or PCX. These formats are wrappers around the TwelveMonkeys library. Gradle implementation ( \"com.sksamuel.scrimage:scrimage-core:<version>\" ) SBT libraryDependencies += \"com.sksamuel.scrimage\" % \"scrimage-core\" % \"$version\" libraryDependencies += \"com.sksamuel.scrimage\" %% \"scrimage-scala\" % \"$version\" Maven <dependency> <groupId> com.sksamuel.scrimage </groupId> <artifactId> scrimage-core </artifactId> <version> ${version} </version> </dependency> Scala Helpers If you are using Scala and you have added the scala module, then add the import import com.sksamuel.scrimage.scala._ to bring into scope some useful implicits. Firstly, an implicit PNGWriter so you do not have to specify it when outputting images. Secondly, a conversion to / from java.awt.Color and Scrimage's RGBColor . Lastly, forall, foreach and map methods on ImmutableImage which work with Scala functions.","title":"Quick start"},{"location":"quick_start/#including-scrimage-in-your-project","text":"Scrimage is available on maven central. There are several modules. One is the scrimage-core library which is required. The others are scrimage-filters , scrimage-formats-extra , scrimage-webp . And if you're using Scala you can also add scrimage-scala_2.12 or scrimage-scala_2.13 for enhanced scala functions. They are split into several modules because the image filters is a large jar, and most people just want the basic resize/scale/load/save functionality. The scrimage-formats-extra package brings in readers/writers for less common formats such as BMP, Tiff or PCX. These formats are wrappers around the TwelveMonkeys library. Gradle implementation ( \"com.sksamuel.scrimage:scrimage-core:<version>\" ) SBT libraryDependencies += \"com.sksamuel.scrimage\" % \"scrimage-core\" % \"$version\" libraryDependencies += \"com.sksamuel.scrimage\" %% \"scrimage-scala\" % \"$version\" Maven <dependency> <groupId> com.sksamuel.scrimage </groupId> <artifactId> scrimage-core </artifactId> <version> ${version} </version> </dependency>","title":"Including Scrimage in your project"},{"location":"quick_start/#scala-helpers","text":"If you are using Scala and you have added the scala module, then add the import import com.sksamuel.scrimage.scala._ to bring into scope some useful implicits. Firstly, an implicit PNGWriter so you do not have to specify it when outputting images. Secondly, a conversion to / from java.awt.Color and Scrimage's RGBColor . Lastly, forall, foreach and map methods on ImmutableImage which work with Scala functions.","title":"Scala Helpers"},{"location":"resize/","text":"Resize Resizes the canvas to the given dimensions. This does not scale the image but simply changes the dimensions of the canvas on which the image is sitting. Specifying a larger size will pad the image with a background color and specifying a smaller size will crop the image. This is the operation most people want when they think of crop. We can specify a position which will be used to anchor the source image in the new canvas. When resizing, we can specify a factor to multiply the current dimensions by, such as image.resize(0.5) , or we can specify target sizes specifically, such as image.resizeTo(400,300) , or we can resize the width or height independently. Examples Using this image as our input: image . resize ( 0.75 ) // with added colour to show the padded canvas image . resizeTo ( 400 , 400 , Color . MAGENTA ) // anchoring the source to the bottom right corner image . resizeTo ( 400 , 300 , Position . BottomRight ) // resizing only one dimension image . resizeToWidth ( 400 )","title":"Resize"},{"location":"resize/#resize","text":"Resizes the canvas to the given dimensions. This does not scale the image but simply changes the dimensions of the canvas on which the image is sitting. Specifying a larger size will pad the image with a background color and specifying a smaller size will crop the image. This is the operation most people want when they think of crop. We can specify a position which will be used to anchor the source image in the new canvas. When resizing, we can specify a factor to multiply the current dimensions by, such as image.resize(0.5) , or we can specify target sizes specifically, such as image.resizeTo(400,300) , or we can resize the width or height independently.","title":"Resize"},{"location":"resize/#examples","text":"Using this image as our input: image . resize ( 0.75 ) // with added colour to show the padded canvas image . resizeTo ( 400 , 400 , Color . MAGENTA ) // anchoring the source to the bottom right corner image . resizeTo ( 400 , 300 , Position . BottomRight ) // resizing only one dimension image . resizeToWidth ( 400 )","title":"Examples"},{"location":"rotate/","text":"Rotate Rotates the image clockwise or anti-clockwise. Examples Using this image scaled to 640 x 360 as our input: Code Output image.rotateLeft() image.rotateRight() image.rotate(new Radians(1.15))","title":"Rotate"},{"location":"rotate/#rotate","text":"Rotates the image clockwise or anti-clockwise.","title":"Rotate"},{"location":"rotate/#examples","text":"Using this image scaled to 640 x 360 as our input: Code Output image.rotateLeft() image.rotateRight() image.rotate(new Radians(1.15))","title":"Examples"},{"location":"scale/","text":"Scale Scales an image up or down. This operation will change both the canvas and the image. This is what most people want when they think of \"resizing\" an image. If instead, we wish to change the image \"canvas\" without scaling up or down, then resize is the right operation. We can perform a scale operation with a specified width and height. Or we can specify only a width or height and Scrimage will adjust the other dimension to keep the aspect ratio constant. Alternatively, we can specify a scale factor, which will multiply the width and height by that factor. Examples Using this image as our input: image . scaleToWidth ( 400 ) // keeps aspect ratio image . scaleToHeight ( 200 ) // keeps aspect ratio image . scaleTo ( 400 , 400 ) // using the fast scale method image . scaleTo ( 400 , 400 , ScaleMethod . FastScale ) image . scale ( 0.5 ) // keeps aspect ratio, applies factor to width and height Scale Algorithms Each scale operation has a ScaleMethod parameter that allows us to specify the algorithm to be used when performing the scale. Options are FastScale , Lanczos3 , BSpline , Bilinear , Bicubic . Bicucbic is the default. Here is the same image scaled using each of the algorithms. Click on the image to see the full size. Fast Scale BSpline Lanczos3 Bilinear Bicubic","title":"Scale"},{"location":"scale/#scale","text":"Scales an image up or down. This operation will change both the canvas and the image. This is what most people want when they think of \"resizing\" an image. If instead, we wish to change the image \"canvas\" without scaling up or down, then resize is the right operation. We can perform a scale operation with a specified width and height. Or we can specify only a width or height and Scrimage will adjust the other dimension to keep the aspect ratio constant. Alternatively, we can specify a scale factor, which will multiply the width and height by that factor.","title":"Scale"},{"location":"scale/#examples","text":"Using this image as our input: image . scaleToWidth ( 400 ) // keeps aspect ratio image . scaleToHeight ( 200 ) // keeps aspect ratio image . scaleTo ( 400 , 400 ) // using the fast scale method image . scaleTo ( 400 , 400 , ScaleMethod . FastScale ) image . scale ( 0.5 ) // keeps aspect ratio, applies factor to width and height","title":"Examples"},{"location":"scale/#scale-algorithms","text":"Each scale operation has a ScaleMethod parameter that allows us to specify the algorithm to be used when performing the scale. Options are FastScale , Lanczos3 , BSpline , Bilinear , Bicubic . Bicucbic is the default. Here is the same image scaled using each of the algorithms. Click on the image to see the full size. Fast Scale BSpline Lanczos3 Bilinear Bicubic","title":"Scale Algorithms"},{"location":"take/","text":"Take Returns a new Image which is the source image, but only keeping a specified number of pixels from the top, bottom, left or right. For example, takeLeft(k) will return a subimage with bounds [0, 0, k, height] . Examples Using this image scaled to 640 x 360 as our input: Code Output image.takeLeft(300) image.takeLeft(300).takeTop(200) image.takeRight(400).takeBottom(200)","title":"Take"},{"location":"take/#take","text":"Returns a new Image which is the source image, but only keeping a specified number of pixels from the top, bottom, left or right. For example, takeLeft(k) will return a subimage with bounds [0, 0, k, height] .","title":"Take"},{"location":"take/#examples","text":"Using this image scaled to 640 x 360 as our input: Code Output image.takeLeft(300) image.takeLeft(300).takeTop(200) image.takeRight(400).takeBottom(200)","title":"Examples"},{"location":"transforms/","text":"Transforms A transform modifies an image and returns a new image derived from that input. A transform is similar to a filter, but where a filter modifies the pixels of an image, a transform can return an entirely new image. Click on an example to see it full screen. Background Gradient Produces a linear gradient background underlay for the two most dominent colours of an image. Java ImmutableImage transformed = image1.transform(new BackgroundGradient(400, 300)) Kotlin val transformed = image1.transform(BackgroundGradient(400, 300)) Scala val transformed = image1.transform(new BackgroundGradient(400, 300)) Input Output","title":"Transforms"},{"location":"transforms/#transforms","text":"A transform modifies an image and returns a new image derived from that input. A transform is similar to a filter, but where a filter modifies the pixels of an image, a transform can return an entirely new image. Click on an example to see it full screen.","title":"Transforms"},{"location":"transforms/#background-gradient","text":"Produces a linear gradient background underlay for the two most dominent colours of an image. Java ImmutableImage transformed = image1.transform(new BackgroundGradient(400, 300)) Kotlin val transformed = image1.transform(BackgroundGradient(400, 300)) Scala val transformed = image1.transform(new BackgroundGradient(400, 300)) Input Output","title":"Background Gradient"},{"location":"translate/","text":"Translate Returns a new image with the original image translated (moved) the specified number of pixels. We can translate on either axis and in either direction. Additionally, a background colour can be specified. Examples Using this image as our input: // translate 100 pixels right image . translate ( 100 , 0 ) // translate 100 pixels right with specified bg image . translate ( 100 , 0 , Color . BLUE ) // translate on both axis image . translate ( 120 , 80 ) // translate in negative directions with specified bg image . translate ( 120 , - 80 , Color . RED )","title":"Translate"},{"location":"translate/#translate","text":"Returns a new image with the original image translated (moved) the specified number of pixels. We can translate on either axis and in either direction. Additionally, a background colour can be specified.","title":"Translate"},{"location":"translate/#examples","text":"Using this image as our input: // translate 100 pixels right image . translate ( 100 , 0 ) // translate 100 pixels right with specified bg image . translate ( 100 , 0 , Color . BLUE ) // translate on both axis image . translate ( 120 , 80 ) // translate in negative directions with specified bg image . translate ( 120 , - 80 , Color . RED )","title":"Examples"},{"location":"trim/","text":"Trim The trim operation shrinks the canvas size on a specified or all sides. You can think of it as removing a border. To remove the same amount of pixels on all side, invoke with a single parameter. image . trim ( 15 ) or to specify each side seperately image . trim ( 5 , 40 , 5 , 19 ) Examples Using this image as our starting input: image . trim ( 50 ) // will remove 50 pixels on all sides image . trimLeft ( 100 ) // remove 100 pixels from the left side image . trimBottom ( 200 ) // will remove 200 pixels from the bottom","title":"Trim"},{"location":"trim/#trim","text":"The trim operation shrinks the canvas size on a specified or all sides. You can think of it as removing a border. To remove the same amount of pixels on all side, invoke with a single parameter. image . trim ( 15 ) or to specify each side seperately image . trim ( 5 , 40 , 5 , 19 )","title":"Trim"},{"location":"trim/#examples","text":"Using this image as our starting input: image . trim ( 50 ) // will remove 50 pixels on all sides image . trimLeft ( 100 ) // remove 100 pixels from the left side image . trimBottom ( 200 ) // will remove 200 pixels from the bottom","title":"Examples"},{"location":"webp/","text":"Webp Support Webp is a method of lossy and lossless compression created by Google. Scrimage provides support for webp through the scrimage-webp module. To use webp, add this module to your build. animated gif to animated webp is not currently supported in this module. This module uses the dwebp and cwebp binaries, created by Google. The scrimage-webp module comes with the linux_x64, window_x64, mac-10.15 binaries already included (see required copyright notice ). If you don't wish to use the embedded binaries, then you can download other versions and place them on your classpath at /webp_binaries/{osName}/dwebp or /webp_binaries/{osName}/cwebp . {osName} must be one of window , linux , mac . ie /webp_binaries/window/cwebp . or just place your binaries into /webp_binaries/dwebp or /webp_binaries/cwebp . then scrimage will use /webp_binaries/{binary} regardless of the binaries which is in os specific directory. Then you should be able to read webp files by using the ImageLoader as normal: ImmutableImage . loader (). fromFile ( new File ( \"someimage.webp\" )) And write out images using the WebpWriter image writer, eg. myimage . output ( WebpWriter . MAX_LOSSLESS_COMPRESSION , \"output.webp\" ); The writer is configuration with options for compression quality, compression method, and lossless compression factor.","title":"Webp"},{"location":"webp/#webp-support","text":"Webp is a method of lossy and lossless compression created by Google. Scrimage provides support for webp through the scrimage-webp module. To use webp, add this module to your build. animated gif to animated webp is not currently supported in this module. This module uses the dwebp and cwebp binaries, created by Google. The scrimage-webp module comes with the linux_x64, window_x64, mac-10.15 binaries already included (see required copyright notice ). If you don't wish to use the embedded binaries, then you can download other versions and place them on your classpath at /webp_binaries/{osName}/dwebp or /webp_binaries/{osName}/cwebp . {osName} must be one of window , linux , mac . ie /webp_binaries/window/cwebp . or just place your binaries into /webp_binaries/dwebp or /webp_binaries/cwebp . then scrimage will use /webp_binaries/{binary} regardless of the binaries which is in os specific directory. Then you should be able to read webp files by using the ImageLoader as normal: ImmutableImage . loader (). fromFile ( new File ( \"someimage.webp\" )) And write out images using the WebpWriter image writer, eg. myimage . output ( WebpWriter . MAX_LOSSLESS_COMPRESSION , \"output.webp\" ); The writer is configuration with options for compression quality, compression method, and lossless compression factor.","title":"Webp Support"},{"location":"zoom/","text":"Zoom Returns a new image that is the result of scaling this image, but without changing the canvas size. This can be thought of as similar to zooming in on a camera. When you zoom on a camera, the size of the viewpane does not increase, and some parts of the image are no longer visible. The zoom operation accepts a scale factor to apply to the dimensions, and optionally a scale method. If the scale method is not specified, then BICUBIC is used. Examples Using this image as our input: // zoom with default scale method image . zoom ( 1.3 ) // zoom with a specified scale method. image . scaleToHeight ( 200 , Scalemethod . FastScale )","title":"Zoom"},{"location":"zoom/#zoom","text":"Returns a new image that is the result of scaling this image, but without changing the canvas size. This can be thought of as similar to zooming in on a camera. When you zoom on a camera, the size of the viewpane does not increase, and some parts of the image are no longer visible. The zoom operation accepts a scale factor to apply to the dimensions, and optionally a scale method. If the scale method is not specified, then BICUBIC is used.","title":"Zoom"},{"location":"zoom/#examples","text":"Using this image as our input: // zoom with default scale method image . zoom ( 1.3 ) // zoom with a specified scale method. image . scaleToHeight ( 200 , Scalemethod . FastScale )","title":"Examples"}]}